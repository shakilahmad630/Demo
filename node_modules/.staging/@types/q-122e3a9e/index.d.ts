// Type definitions for Q 1.5
// Project: https://github.com/kriskowal/q
// Definitions by: Barrie Nemetchek <https://github.com/bnemetchek>
//                 Andrew Gaspar <https://github.com/AndrewGaspar>
//                 John Reilly <https://github.com/johnnyreilly>
//                 Michel Boudreau <https://github.com/mboudreau>
//                 TeamworkGuy2 <https://github.com/TeamworkGuy2>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3

export = Q;
export as namespace Q;

/**
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise (where possible).
 * If value is not a promise, returns a promise that is fulfilled with value.
 */
declare function Q<T>(promise: PromiseLike<T> | T): Q.Promise<T>;
/**
 * Calling with nothing at all creates a void promise
 */
declare function Q(): Q.Promise<void>;

declare namespace Q {
    export type IWhenable<T> = PromiseLike<T> | T;
    export type IPromise<T> = PromiseLike<T>;

    export interface Deferred<T> {
        promise: Promise<T>;

        /**
         * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its
         * fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
         * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
         * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
         * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
         */
        resolve(value?: IWhenable<T>): void;

        /**
         * Calling reject with a reason causes promise to be rejected with that reason.
         */
        reject(reason?: any): void;

        /**
         * Calling notify with a value causes promise to be notified of progress with that value. That is, any onProgress
         * handlers registered with promise or promises derived from promise will be called with the progress value.
         */
        notify(value: any): void;

        /**
         * Returns a function suitable for passing to a Node.js API. That is, it has a signature (err, result) and will
         * reject deferred.promise with err if err is given, or fulfill it with result if that is given.
         */
        makeNodeResolver(): (reason: any, value: T) => void;
    }

    export interface Promise<T> {
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<U>(onFulfill?: ((value: T) => IWhenable<U>) | null, onReject?: ((error: any) => IWhenable<U>) | null, onProgress?: ((progress: any) => any) | null): Promise<U>;
        then<U = T, V = never>(onFulfill?: ((value: T) => IWhenable<U>) | null, onReject?: ((error: any) => IWhenable<V>) | null, onProgress?: ((progress: any) => any) | null): Promise<U | V>;
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so
         * without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded,
         * like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason
         * as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed
         * until the promise returned from callback is finished. Furthermore, if the returned promise rejects, that
         * rejection will be passed down the chain instead of the previous result.
         */
        finally(finallyCallback: () => any): Promise<T>;

        /**
         * Alias for finally() (for non-ES5 browsers)
         */
        fin(finallyCallback: () => any): Promise<T>;

        /**
         * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are
         * rejected, instead calls onRejected with the first rejected promise's rejection reason.
         * This is especially useful in conjunction with all
         */
        spread<U>(onFulfill: (...args: any[]) => IWhenable<U>, onReject?: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(undefined, onRejected).
         */
        catch<U>(onRejected: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * Alias for catch() (for non-ES5 browsers)
         */
        fail<U>(onRejected: (reason: any) => IWhenable<U>): Promise<U>;

        /**
         * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
         */
        progress(onProgress: (progress: any) => any): Promise<T>;

        /**
         * Much like then, but with different behavior around un